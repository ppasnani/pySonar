#!/usr/bin/python -tt

import pyaudio
import wave
from pylab import *
import time
import Queue
import winsound

ChirpFile = "Sound Files/plain_chirp.wav"
transmitChirp = wave.open(ChirpFile, 'rb')

Chunk = 1024
Format = pyaudio.paInt16
SampWidth = transmitChirp.getsampwidth()
Channels = transmitChirp.getnchannels()
Rate = transmitChirp.getframerate()

#Create a synchronized queue that can only hold one list
recordQueue = Queue.Queue(Chunk)

#Callback functions for playing back and recording audio in
#non-blocking mode. See reference 4
def playcallback(in_data, frame_count, time_info, status):
    out_data = transmitChirp.readframes(frame_count)
    return (out_data , pyaudio.paContinue)

def recordcallback(in_data, frame_count, time_info, status):
    recordQueue.put(fromstring(in_data, 'Int16'))
    return (in_data, pyaudio.paContinue)   

#Require: Requires an exisitng pyAudio object which has set
#       up the port audio system
#Ensures: Plays the ChirpFile wave file over the speakers
#       if the speakers are available

#Note: look into threading this. I think the print delay is the only thing
#causing this to play properly
def chirp(p):
    #Returns a tuple (nchannels, sampwidth, framerate, nframes, comptype, compname)
    audioParams = transmitChirp.getparams()
    playstream = p.open(format=p.get_format_from_width(audioParams[1]),
                    channels=audioParams[0],
                    rate=audioParams[2],
                    input=False,
                    output=True,
                    stream_callback=playcallback)
    audioTime = round(float(audioParams[-3]) / audioParams[2], 6)
    #print 'AudioTime:', audioTime
    #Keep just playing the chirp and showing the data
    playstream.start_stream()
    #Temporary delay. Use some function of chirp length or
    #travel time for audio to determine this after threading function
    time.sleep(0.5)
    playstream.stop_stream()
    playstream.close()
    transmitChirp.setpos(0)

#Using [1] as reference
def show_wave(audio):
    #subplot(211)
    #plot(audio)
    #title('Wave form and spectrogram of recorded audio')

    #subplot(212)    
    audioTime = float(len(audio)) / Rate
    #print (len(audio)), 'time', audioTime
        
    spectrogram = specgram(audio, Fs = Rate, scale_by_freq=True, sides='default')
    #xlim([0, audioTime])
    pause(0.5)
    #show()

def main():
    #Instantiate pyAudio
    p = pyaudio.PyAudio()
    #Open stream to record audio data from the mike
    recordstream = p.open(format=p.get_format_from_width(SampWidth),
                          channels=Channels,
                          rate=Rate,
                          input=True,
                          output=False,
                          stream_callback=recordcallback)
    
    recordstream.start_stream()    
    recordData = []
      
    while recordstream.is_active():        
        #Transmit "chirp" to listen for in echoes
        chirp(p)

        #Get the recorded data from the priority queue
        recordData = []
        for i in range(recordQueue.qsize()):            
            recordData.extend(recordQueue.get())
            recordQueue.task_done()
            
        #Display it
        show_wave(recordData)
        
    #Wait for the threads to end and cleanup
    recordQueue.join()
    recordstream.stop_stream()
    recordstream.close()
    
    p.terminate()

if __name__ == '__main__':
    main()

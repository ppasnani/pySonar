#!/usr/bin/python -tt

import pyaudio
import wave
from pylab import *
import time
import Queue
import winsound

ChirpFile = "Sound Files/plain_chirp.wav"
Chunk = 1024
Format = pyaudio.paInt16
Channels = 2
Rate = 44100#384000
Record_Seconds = 1

transmitChirp = wave.open(ChirpFile, 'r')
#out_data = transmitChirp.readframes(Chunk)

#Create a synchronized queue that can only hold one list
recordQueue = Queue.Queue(Chunk)

def callback(in_data, frame_count, time_info, status):
    #print in_data[0:5]
    out_data = transmitChirp.readframes(frame_count)
    #int_out_data = fromstring(out_data, '
    #recordData.extend(fromstring(in_data, 'Int16'))
    #out_data = transmitChirp.readframes(Chunk)    
    #print out_data
    transmitChirp.setpos(0)

    chirp_data = out_data
    print chirp_data[0:10]
    #chirp_data = []
    #for b in out_data:
    #    #if b != '':
    #    chirp_data.extend(int(b))
    
    recordQueue.put(fromstring(in_data, 'Int16'))
    print 'frame', frame_count, 'data', len(out_data), 'indata', len(in_data)   
    #recordQueue.task_done()
    #print 'stuck here'
    return(in_data , pyaudio.paContinue)

#Require: Requires an exisitng pyAudio object which has set
#       up the port audio system
#Ensures: Plays the ChirpFile wave file over the speakers
#       if the speakers are available

def chirp(p):
    #transmitChirp = wave.open(ChirpFile, 'r')

    #p = pyaudio.PyAudio()
    stream = p.open(format=p.get_format_from_width(transmitChirp.getsampwidth()),
                    channels=transmitChirp.getnchannels(),
                    rate=transmitChirp.getframerate(),
                    output=True)
    data = transmitChirp.readframes(Chunk)

    while data != '':
        stream.write(data)
        data = transmitChirp.readframes(Chunk)

    stream.stop_stream()
    stream.close()

#Requires: Requires an existing pyAudio object which has set
#       up the port audio system
#Ensures: Returns an array of frames containing the recorded data

def record(p):
    stream = p.open(format=Format,
                    channels=Channels,
                    rate=Rate,
                    input=True,
                    frames_per_buffer=Chunk)
    print 'Recording'
    frames = []
    framesNum = []
    for i in range(0, int(Rate/Chunk * Record_Seconds)):
        data = stream.read(Chunk)
        frames.append(data)
        #numList = fromstring(data, 'Int16')
        #for l in numList:
        #    framesNum.append(l)
        framesNum.extend(fromstring(data, 'Int16'))

    #print frames[0:20]
    stream.stop_stream()
    stream.close()
    #print framesNum[0:5]
    return framesNum

#Using [1] as reference
def show_wave(audio):
    #subplot(211)
    #plot(audio)
    #title('Wave form and spectrogram of recorded audio')

    #subplot(212)    
    audioTime = float(len(audio)) / Rate
    #print (len(audio)), 'time', audioTime
        
    spectrogram = specgram(audio, Fs = Rate, scale_by_freq=True, sides='default')
    xlim([0, audioTime])
    pause(0.01)
    #show()

def main():
    #Instantiate pyAudio
    p = pyaudio.PyAudio()
    #while (True):
        #Use pyAudio object to transmit and record sound
    #    chirp(p)
    #    audio = record(p)
    #    show_wave(audio)
    stream = p.open(format=p.get_format_from_width(transmitChirp.getsampwidth()),
                    channels=Channels,
                    rate=Rate,
                    input=True,
                    output=False,
                    stream_callback=callback)

    stream.start_stream()
    #time.sleep(1)
    #stream.stop_stream()
    #print len(recordData), "my length", recordDataLength
    #show_wave(recordData)
    recordData = []

    chirp(p)
    
    
    while True:
        #Keep just playing the chirp and showing the data
        #chirp(p)
        #time.sleep(0.5)
        #Stuck here trying to find a way to get new data from the callback
        #function
        #newData = recordData
        recordData = []
        for i in range(recordQueue.qsize()):
            #print 'record extend'
            recordData.extend(recordQueue.get(block=False))
            recordQueue.task_done()
            #print 'i', i
        #for l in recordFrameData:
        #    recordData.append(l)
        #print 'recorddata', recordData[0:10]
        
        #print "recorded data", recordData[0:100]
        show_wave(recordData)

    recordQueue.join()
    stream.stop_stream()
    stream.close()
    
    p.terminate()

if __name__ == '__main__':
    main()

#!/usr/bin/python -tt

import pyaudio
import wave
from pylab import *
import time
import Queue
import winsound

ChirpFile = "Sound Files/plain_chirp.wav"
transmitChirp = wave.open(ChirpFile, 'rb')

Chunk = 1024
Format = pyaudio.paInt16
SampWidth = transmitChirp.getsampwidth()
Channels = transmitChirp.getnchannels()
Rate = transmitChirp.getframerate()
#Record_Seconds = 1


#out_data = transmitChirp.readframes(Chunk)

#Create a synchronized queue that can only hold one list
recordQueue = Queue.Queue(Chunk)

def playcallback(in_data, frame_count, time_info, status):
    #print in_data[0:5]
    out_data = transmitChirp.readframes(frame_count)
    #int_out_data = fromstring(out_data, '
    #recordData.extend(fromstring(in_data, 'Int16'))
    #out_data = transmitChirp.readframes(Chunk)    
    #print out_data
    #transmitChirp.setpos(0)
    
    #chirp_data = []
    #int_out_data = fromstring(out_data, 'Int16')
    #for b in int_out_data:
        #print getBitArray(b)
    #    chirp_data.extend(getBitArray(b))        
    
    #recordQueue.put(fromstring(in_data, 'Int16'))
    #print 'frame', frame_count, 'data', len(out_data), 'indata', len(in_data)   
    #recordQueue.task_done()
    #print 'stuck here'
    #if len(chirp_data) is 0:
    #    return (in_data, pyaudio.paContinue)
    #else:
    return (out_data , pyaudio.paContinue)

def recordcallback(in_data, frame_count, time_info, status):
    recordQueue.put(fromstring(in_data, 'Int16'))
    return (in_data, pyaudio.paContinue)

#Require: An integer intNum
#Ensures: Returns a list of numbers [0, 1] of length 16
#       that represent intNum in binary format
def getBitArray(intNum):
    if intNum > 0:
        #bin(num) Returns in string format 0b1011....
        bitList = fromstring(bin(intNum)[2:], 'bool').tolist()
        #return ()
    else:
        #Negative num returns in string format -0b101.
        bitList = fromstring(bin(intNum)[3:], 'bool').tolist()
        #return (fromstring(bin(intNum)[3:], 'bool'))
    
    zeroPad = 16 - len(bitList)
    #print 'zPad', zeroPad, 'bList', len(bitList), 'list', bitList
    #if len(bitList) is 0:
    #    return [False] * 16
    #else:
    return (([False] * zeroPad) + bitList)
    

#Require: Requires an exisitng pyAudio object which has set
#       up the port audio system
#Ensures: Plays the ChirpFile wave file over the speakers
#       if the speakers are available

def chirp(p):
    #transmitChirp = wave.open(ChirpFile, 'r')

    #p = pyaudio.PyAudio()
    stream = p.open(format=p.get_format_from_width(transmitChirp.getsampwidth()),
                    channels=transmitChirp.getnchannels(),
                    rate=transmitChirp.getframerate(),
                    output=True)
    data = transmitChirp.readframes(Chunk)

    while data != '':
        stream.write(data)
        data = transmitChirp.readframes(Chunk)

    stream.stop_stream()
    stream.close()

#Requires: Requires an existing pyAudio object which has set
#       up the port audio system
#Ensures: Returns an array of frames containing the recorded data

def record(p):
    stream = p.open(format=Format,
                    channels=Channels,
                    rate=Rate,
                    input=True,
                    frames_per_buffer=Chunk)
    print 'Recording'
    frames = []
    framesNum = []
    for i in range(0, int(Rate/Chunk * Record_Seconds)):
        data = stream.read(Chunk)
        frames.append(data)
        #numList = fromstring(data, 'Int16')
        #for l in numList:
        #    framesNum.append(l)
        framesNum.extend(fromstring(data, 'Int16'))

    #print frames[0:20]
    stream.stop_stream()
    stream.close()
    #print framesNum[0:5]
    return framesNum

#Using [1] as reference
def show_wave(audio):
    subplot(211)
    plot(audio)
    title('Wave form and spectrogram of recorded audio')

    subplot(212)    
    audioTime = float(len(audio)) / Rate
    #print (len(audio)), 'time', audioTime
        
    spectrogram = specgram(audio, Fs = Rate, scale_by_freq=True, sides='default')
    #xlim([0, audioTime])
    pause(0.1)
    #show()

def main():
    #Instantiate pyAudio
    p = pyaudio.PyAudio()
    #while (True):
        #Use pyAudio object to transmit and record sound
    #    chirp(p)
    #    audio = record(p)
    #    show_wave(audio)
    recordstream = p.open(format=p.get_format_from_width(SampWidth),
                          channels=Channels,
                          rate=Rate,
                          input=True,
                          output=False,
                          stream_callback=recordcallback)
    
    #time.sleep(1)
    recordstream.start_stream()
    #print len(recordData), "my length", recordDataLength
    #show_wave(recordData)
    recordData = []
    
    #chirp(p)        
    while recordstream.is_active():
        playstream = p.open(format=p.get_format_from_width(transmitChirp.getsampwidth()),
                    channels=transmitChirp.getnchannels(),
                    rate=transmitChirp.getframerate(),
                    input=False,
                    output=True,
                    stream_callback=playcallback)
        #Keep just playing the chirp and showing the data
        playstream.start_stream()
        time.sleep(0.5)
        playstream.stop_stream()
        playstream.close()
        transmitChirp.setpos(0)
        #chirp(p)
        #time.sleep(0.5)
        #Stuck here trying to find a way to get new data from the callback
        #function
        #newData = recordData
        recordData = []
        for i in range(recordQueue.qsize()):
            #print 'record extend'
            recordData.extend(recordQueue.get())
            recordQueue.task_done()
            #print 'i', i
        #for l in recordFrameData:
        #    recordData.append(l)
        #print 'recorddata', recordData[0:10]
        
        #print "recorded data", recordData[0:100]
        show_wave(recordData)
        
        #time.sleep(0.5)

    recordQueue.join()
    recordstream.stop_stream()
    recordstream.close()
    playstream.close()
    
    p.terminate()

if __name__ == '__main__':
    main()
